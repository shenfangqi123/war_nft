{"version":3,"sources":["assets/scripts/WizSprite.js"],"names":["mySprite","require","common","cc","Class","properties","role","start","_animation","getComponent","Animation","WrapMode","Loop","remove","play","shadow","destroy","blood","dieStart","console","log","dieEnd","footStart","footEnd","node","footPrint","zIndex","scaleX","scaleY","frame1Evt","dispShadow","frame2Evt","frame3Evt","frame4Evt","frame5Evt","frame6Evt","frame7Evt","aFrame1Evt","aFrame2Evt","aFrame3Evt","aFrame4Evt","aFrame5Evt","playAni","agent","agentFuture","isMainPlayer","playAngleAnimationRemote"],"mappings":"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","sourceRoot":"/","sourcesContent":["var mySprite = require(\"MySprite\");\nvar common = require(\"Common\");\n\ncc.Class({\n    extends: mySprite,\n\n    properties: {\n        role:\"wiz\",\n    },\n\n    start () {\n        this._animation = this.getComponent(cc.Animation);\n        this._animation.WrapMode = cc.WrapMode.Loop;\n    },\n\n    remove: function() {\n        this._animation.play(\"dieoff2\");\n        this.shadow.destroy();\n        this.blood.destroy();\n    },\n\n    dieStart: function() {\n        console.log(\"die start\");\n    },\n\n    dieEnd: function() {\n        console.log(\"die end\");\n        this._animation.play(\"footprint\");\n    },\n\n    //ske clip ske_bomb, foot print start evt\n    footStart: function() {\n        console.log(\"foot start\");\n    },\n\n    footEnd: function() {\n        console.log(\"foot end\");\n        this.node.destroy();\n    },\n\n    //ske clip ske_bomb, foot print start evt\n    footPrint: function() {\n        this.node.zIndex = -1;\n        this.node.scaleX = 1;\n        this.node.scaleY = 1;\n    },\n\n/*\n    //ske clip ske_bomb, called by first frame of ske_bomb\n    beforeKill: function() {\n        //this.shadow.destroy();\n    },\n\n    //ske clip ske_bomb, called by last frame of ske_bomb\n    afterKill: function() {\n        console.log(\"--remove archer node--\");\n        this.node.destroy();\n    },\n*/\n\n    frame1Evt: function() {\n        this.dispShadow(1);\n    },\n\n    frame2Evt: function() {\n        this.dispShadow(2);\n    },\n\n    frame3Evt: function() {\n        this.dispShadow(3);\n    },\n\n    frame4Evt: function() {\n        this.dispShadow(4);\n    },\n\n    frame5Evt: function() {\n        this.dispShadow(5);\n    },\n\n    frame6Evt: function() {\n        this.dispShadow(6);\n    },\n\n    frame7Evt: function() {\n        this.dispShadow(7);\n    },\n\n\n    aFrame1Evt: function() {\n        this.dispShadow(1);\n    },\n\n    aFrame2Evt: function() {\n        this.dispShadow(3);\n    },\n\n    aFrame3Evt: function() {\n        this.dispShadow(5);\n    },\n\n    aFrame4Evt: function() {\n    },\n\n    aFrame5Evt: function() {\n        this.dispShadow(7);\n    },\n\n    playAni: function(agent, agentFuture, isMainPlayer) {\n        this.playAngleAnimationRemote(agent, agentFuture, isMainPlayer);\n    },\n\n/*\n    isEnemyBase: function(baseId) {\n        if(baseId == 1 || baseId == 2 || baseId == 3) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    isEnemyFort: function(isAgentHero, mainPlayer) {\n        if(isAgentHero && mainPlayer == 2) {\n            return true;\n        } \n        if(!isAgentHero && mainPlayer == 1) {\n            return true;\n        } \n        return false;\n    },\n\n    playBaseWarriorAnimationDefault: function(actType, baseId) {\n        var actName;\n\n        if(this.isEnemyBase(baseId)) {\n            actName = \"lr_s_walk\";\n        } else {\n            actName = \"lr_n_walk\";\n        }\n\n        if(actType == \"move\" && this.lastAct == actName) {\n            return;\n        }\n\n        var randomTime = Math.ceil(Math.random()*125)/100;\n        this._animation.play(actName, randomTime);\n        this.lastAct = actName;\n    },\n\n    playFortWarriorAnimationDefault: function(actType, isAgentHero, mainPlayer) {\n        var actName;\n\n        if(this.isEnemyFort(isAgentHero, mainPlayer)) {\n            actName = \"lr_s_walk\";\n        } else {\n            actName = \"lr_n_walk\";\n        }\n\n        if(actType == \"move\" && this.lastAct == actName) {\n            return;\n        }\n\n        var randomTime = Math.ceil(Math.random()*125)/100;\n        this._animation.play(actName, randomTime);\n        this.lastAct = actName;\n    },\n\n    playBaseWarriorAnimation: function(agent, isMainPlayer, actType) {\n        var fx,fy;\n        var targetYOffset = common.attackTargetYOffset;\n        var ex, ey;\n        var angle;\n        var x = agent.mypos.x; \n        var y = agent.mypos.y; \n\n        var startPos,targetPos,startEPos, targetEPos, vt, vtE;\n\n        var randomTime = Math.ceil(Math.random()*125)/100;\n        var actName = \"\";\n        var then;\n        var angleInfo;\n\n        // user to control the up and down user Y postion offset.\n        var offsetDir = 1;\n\n        if(isMainPlayer == 1) {\n            offsetDir = 1;\n        }\n        else if(isMainPlayer == 2) {\n            offsetDir = -1;\n        }\n\n        ex = agent.enemypos.x; \n        ey = agent.enemypos.y; \n\n        // dir according to enemy position\n        startPos  = cc.v2((x)*30, (y)*30);\n        targetPos = cc.v2((ex)*30, (ey)*30+targetYOffset*offsetDir);\n        vt = startPos.sub(targetPos);\n\n        if(vt.x == 0 && vt.y == 0) {\n            return;\n        }\n\n        //if dir no changed, vt.x or vt.y is 0, atan value should be invaild\n        if(vt.x == 0) {\n            vt.x = 0.1;\n        }\n        if(vt.y == 0) {\n            vt.y = 0.1;\n        }\n\n        //if postion not changed, do nothing, or the math.atan will do error.\n        if(vt.x != 0 && vt.y != 0) {\n            var ag = 180/Math.PI * Math.atan(vt.x/vt.y);\n            angle = ag;\n            if(vt.y >= 0) {\n                //when down to up\n                angle = ag + 180;\n            } \n        } \n\n        if(this._animation) {\n            angleInfo = this.getActnameByAngle(angle, actType);\n            actName = angleInfo.actName;\n\n            //used to mirror a sprite.\n            this.node.scaleX = angleInfo.scaleX;\n\n            //if already in attack mode, just skip the animation\n            if(this.lastAct != actName || actType == \"sa\") {\n                if(actType == \"sa\") {\n                    this._animation.stop();\n                    this._animation.play(actName);\n                } else {\n                    //walking action.\n                    this._animation.play(actName, randomTime);\n                }\n                this.angle = angle;\n                this.lastAct = actName;\n                this.lastScaleX = angleInfo.scaleX;\n            }\n        }\n\n    },\n*/\n\n});\n"]}